/* tslint:disable */
/* eslint-disable */
/**
 * MIT OL Unified Ecommerce API
 * MIT public API
 *
 * The version of the OpenAPI document: 0.0.1 (v0)
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration"
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios"
import globalAxios from "axios"
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common"
import type { RequestArgs } from "./base"
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base"

/**
 * Basket model serializer
 * @export
 * @interface Basket
 */
export interface Basket {
  /**
   *
   * @type {number}
   * @memberof Basket
   */
  id: number
  /**
   *
   * @type {number}
   * @memberof Basket
   */
  user: number
  /**
   *
   * @type {string}
   * @memberof Basket
   */
  basket_items: string
}
/**
 * BasketItem model serializer
 * @export
 * @interface BasketItem
 */
export interface BasketItem {
  /**
   *
   * @type {number}
   * @memberof BasketItem
   */
  basket: number
  /**
   *
   * @type {number}
   * @memberof BasketItem
   */
  product: number
  /**
   *
   * @type {number}
   * @memberof BasketItem
   */
  id: number
}
/**
 * BasketItem model serializer
 * @export
 * @interface BasketItemRequest
 */
export interface BasketItemRequest {
  /**
   *
   * @type {number}
   * @memberof BasketItemRequest
   */
  basket: number
  /**
   *
   * @type {number}
   * @memberof BasketItemRequest
   */
  product: number
}
/**
 * Serializer for IntegratedSystem model.
 * @export
 * @interface IntegratedSystem
 */
export interface IntegratedSystem {
  /**
   *
   * @type {number}
   * @memberof IntegratedSystem
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof IntegratedSystem
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof IntegratedSystem
   */
  slug?: string | null
  /**
   *
   * @type {string}
   * @memberof IntegratedSystem
   */
  description?: string
}
/**
 * Serializer for IntegratedSystem model.
 * @export
 * @interface IntegratedSystemRequest
 */
export interface IntegratedSystemRequest {
  /**
   *
   * @type {string}
   * @memberof IntegratedSystemRequest
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof IntegratedSystemRequest
   */
  slug?: string | null
  /**
   *
   * @type {string}
   * @memberof IntegratedSystemRequest
   */
  description?: string
}
/**
 * Serializes a line item for an order.
 * @export
 * @interface Line
 */
export interface Line {
  /**
   *
   * @type {number}
   * @memberof Line
   */
  id: number
  /**
   *
   * @type {number}
   * @memberof Line
   */
  quantity: number
  /**
   *
   * @type {string}
   * @memberof Line
   */
  item_description: string
  /**
   *
   * @type {string}
   * @memberof Line
   */
  unit_price: string
  /**
   *
   * @type {string}
   * @memberof Line
   */
  total_price: string
  /**
   *
   * @type {Product}
   * @memberof Line
   */
  product: Product
}
/**
 *
 * @export
 * @interface Nested
 */
export interface Nested {
  /**
   *
   * @type {number}
   * @memberof Nested
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof Nested
   */
  password: string
  /**
   *
   * @type {string}
   * @memberof Nested
   */
  last_login?: string | null
  /**
   * Designates that this user has all permissions without explicitly assigning them.
   * @type {boolean}
   * @memberof Nested
   */
  is_superuser?: boolean
  /**
   * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
   * @type {string}
   * @memberof Nested
   */
  username: string
  /**
   *
   * @type {string}
   * @memberof Nested
   */
  first_name?: string
  /**
   *
   * @type {string}
   * @memberof Nested
   */
  last_name?: string
  /**
   *
   * @type {string}
   * @memberof Nested
   */
  email?: string
  /**
   * Designates whether the user can log into this admin site.
   * @type {boolean}
   * @memberof Nested
   */
  is_staff?: boolean
  /**
   * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
   * @type {boolean}
   * @memberof Nested
   */
  is_active?: boolean
  /**
   *
   * @type {string}
   * @memberof Nested
   */
  date_joined?: string
  /**
   * The groups this user belongs to. A user will get all permissions granted to each of their groups.
   * @type {Array<number>}
   * @memberof Nested
   */
  groups?: Array<number>
  /**
   * Specific permissions for this user.
   * @type {Array<number>}
   * @memberof Nested
   */
  user_permissions?: Array<number>
}
/**
 * Serializer for order history.
 * @export
 * @interface OrderHistory
 */
export interface OrderHistory {
  /**
   *
   * @type {number}
   * @memberof OrderHistory
   */
  id: number
  /**
   *
   * @type {StateEnum}
   * @memberof OrderHistory
   */
  state?: StateEnum
  /**
   *
   * @type {string}
   * @memberof OrderHistory
   */
  reference_number?: string
  /**
   *
   * @type {Nested}
   * @memberof OrderHistory
   */
  purchaser: Nested
  /**
   *
   * @type {string}
   * @memberof OrderHistory
   */
  total_price_paid: string
  /**
   *
   * @type {Array<Line>}
   * @memberof OrderHistory
   */
  lines: Array<Line>
  /**
   *
   * @type {string}
   * @memberof OrderHistory
   */
  created_on: string
  /**
   *
   * @type {string}
   * @memberof OrderHistory
   */
  updated_on: string
}

/**
 *
 * @export
 * @interface PaginatedBasketItemList
 */
export interface PaginatedBasketItemList {
  /**
   *
   * @type {number}
   * @memberof PaginatedBasketItemList
   */
  count: number
  /**
   *
   * @type {string}
   * @memberof PaginatedBasketItemList
   */
  next?: string | null
  /**
   *
   * @type {string}
   * @memberof PaginatedBasketItemList
   */
  previous?: string | null
  /**
   *
   * @type {Array<BasketItem>}
   * @memberof PaginatedBasketItemList
   */
  results: Array<BasketItem>
}
/**
 *
 * @export
 * @interface PaginatedBasketList
 */
export interface PaginatedBasketList {
  /**
   *
   * @type {number}
   * @memberof PaginatedBasketList
   */
  count: number
  /**
   *
   * @type {string}
   * @memberof PaginatedBasketList
   */
  next?: string | null
  /**
   *
   * @type {string}
   * @memberof PaginatedBasketList
   */
  previous?: string | null
  /**
   *
   * @type {Array<Basket>}
   * @memberof PaginatedBasketList
   */
  results: Array<Basket>
}
/**
 *
 * @export
 * @interface PaginatedIntegratedSystemList
 */
export interface PaginatedIntegratedSystemList {
  /**
   *
   * @type {number}
   * @memberof PaginatedIntegratedSystemList
   */
  count: number
  /**
   *
   * @type {string}
   * @memberof PaginatedIntegratedSystemList
   */
  next?: string | null
  /**
   *
   * @type {string}
   * @memberof PaginatedIntegratedSystemList
   */
  previous?: string | null
  /**
   *
   * @type {Array<IntegratedSystem>}
   * @memberof PaginatedIntegratedSystemList
   */
  results: Array<IntegratedSystem>
}
/**
 *
 * @export
 * @interface PaginatedOrderHistoryList
 */
export interface PaginatedOrderHistoryList {
  /**
   *
   * @type {number}
   * @memberof PaginatedOrderHistoryList
   */
  count: number
  /**
   *
   * @type {string}
   * @memberof PaginatedOrderHistoryList
   */
  next?: string | null
  /**
   *
   * @type {string}
   * @memberof PaginatedOrderHistoryList
   */
  previous?: string | null
  /**
   *
   * @type {Array<OrderHistory>}
   * @memberof PaginatedOrderHistoryList
   */
  results: Array<OrderHistory>
}
/**
 *
 * @export
 * @interface PaginatedProductList
 */
export interface PaginatedProductList {
  /**
   *
   * @type {number}
   * @memberof PaginatedProductList
   */
  count: number
  /**
   *
   * @type {string}
   * @memberof PaginatedProductList
   */
  next?: string | null
  /**
   *
   * @type {string}
   * @memberof PaginatedProductList
   */
  previous?: string | null
  /**
   *
   * @type {Array<Product>}
   * @memberof PaginatedProductList
   */
  results: Array<Product>
}
/**
 * Serializer for IntegratedSystem model.
 * @export
 * @interface PatchedIntegratedSystemRequest
 */
export interface PatchedIntegratedSystemRequest {
  /**
   *
   * @type {string}
   * @memberof PatchedIntegratedSystemRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof PatchedIntegratedSystemRequest
   */
  slug?: string | null
  /**
   *
   * @type {string}
   * @memberof PatchedIntegratedSystemRequest
   */
  description?: string
}
/**
 * Serializer for Product model.
 * @export
 * @interface PatchedProductRequest
 */
export interface PatchedProductRequest {
  /**
   * SKU of the product.
   * @type {string}
   * @memberof PatchedProductRequest
   */
  sku?: string
  /**
   * Short name of the product, displayed in carts/etc.
   * @type {string}
   * @memberof PatchedProductRequest
   */
  name?: string
  /**
   * Price (decimal to two places)
   * @type {string}
   * @memberof PatchedProductRequest
   */
  price?: string
  /**
   * Long description of the product.
   * @type {string}
   * @memberof PatchedProductRequest
   */
  description?: string
  /**
   * System-specific data for the product (in JSON).
   * @type {any}
   * @memberof PatchedProductRequest
   */
  system_data?: any | null
  /**
   * Owner system of the product.
   * @type {number}
   * @memberof PatchedProductRequest
   */
  system?: number
}
/**
 * Serializer for Product model.
 * @export
 * @interface Product
 */
export interface Product {
  /**
   *
   * @type {number}
   * @memberof Product
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof Product
   */
  deleted_on: string | null
  /**
   *
   * @type {boolean}
   * @memberof Product
   */
  deleted_by_cascade: boolean
  /**
   *
   * @type {string}
   * @memberof Product
   */
  created_on: string
  /**
   *
   * @type {string}
   * @memberof Product
   */
  updated_on: string
  /**
   * SKU of the product.
   * @type {string}
   * @memberof Product
   */
  sku: string
  /**
   * Short name of the product, displayed in carts/etc.
   * @type {string}
   * @memberof Product
   */
  name: string
  /**
   * Price (decimal to two places)
   * @type {string}
   * @memberof Product
   */
  price: string
  /**
   * Long description of the product.
   * @type {string}
   * @memberof Product
   */
  description: string
  /**
   * System-specific data for the product (in JSON).
   * @type {any}
   * @memberof Product
   */
  system_data?: any | null
  /**
   * Owner system of the product.
   * @type {number}
   * @memberof Product
   */
  system: number
}
/**
 * Serializer for Product model.
 * @export
 * @interface ProductRequest
 */
export interface ProductRequest {
  /**
   * SKU of the product.
   * @type {string}
   * @memberof ProductRequest
   */
  sku: string
  /**
   * Short name of the product, displayed in carts/etc.
   * @type {string}
   * @memberof ProductRequest
   */
  name: string
  /**
   * Price (decimal to two places)
   * @type {string}
   * @memberof ProductRequest
   */
  price: string
  /**
   * Long description of the product.
   * @type {string}
   * @memberof ProductRequest
   */
  description: string
  /**
   * System-specific data for the product (in JSON).
   * @type {any}
   * @memberof ProductRequest
   */
  system_data?: any | null
  /**
   * Owner system of the product.
   * @type {number}
   * @memberof ProductRequest
   */
  system: number
}
/**
 * * `pending` - Pending * `fulfilled` - Fulfilled * `canceled` - Canceled * `refunded` - Refunded * `declined` - Declined * `errored` - Errored * `review` - Review
 * @export
 * @enum {string}
 */

export const StateEnum = {
  /**
   * Pending
   */
  Pending: "pending",
  /**
   * Fulfilled
   */
  Fulfilled: "fulfilled",
  /**
   * Canceled
   */
  Canceled: "canceled",
  /**
   * Refunded
   */
  Refunded: "refunded",
  /**
   * Declined
   */
  Declined: "declined",
  /**
   * Errored
   */
  Errored: "errored",
  /**
   * Review
   */
  Review: "review",
} as const

export type StateEnum = (typeof StateEnum)[keyof typeof StateEnum]

/**
 * MetaApi - axios parameter creator
 * @export
 */
export const MetaApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Viewset for IntegratedSystem model.
     * @param {IntegratedSystemRequest} IntegratedSystemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaIntegratedSystemCreate: async (
      IntegratedSystemRequest: IntegratedSystemRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'IntegratedSystemRequest' is not null or undefined
      assertParamExists(
        "metaIntegratedSystemCreate",
        "IntegratedSystemRequest",
        IntegratedSystemRequest,
      )
      const localVarPath = `/api/v0/meta/integrated_system/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        IntegratedSystemRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {number} id A unique integer value identifying this integrated system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaIntegratedSystemDestroy: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("metaIntegratedSystemDestroy", "id", id)
      const localVarPath = `/api/v0/meta/integrated_system/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaIntegratedSystemList: async (
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/meta/integrated_system/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {number} id A unique integer value identifying this integrated system.
     * @param {PatchedIntegratedSystemRequest} [PatchedIntegratedSystemRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaIntegratedSystemPartialUpdate: async (
      id: number,
      PatchedIntegratedSystemRequest?: PatchedIntegratedSystemRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("metaIntegratedSystemPartialUpdate", "id", id)
      const localVarPath = `/api/v0/meta/integrated_system/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        PatchedIntegratedSystemRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {number} id A unique integer value identifying this integrated system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaIntegratedSystemRetrieve: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("metaIntegratedSystemRetrieve", "id", id)
      const localVarPath = `/api/v0/meta/integrated_system/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {number} id A unique integer value identifying this integrated system.
     * @param {IntegratedSystemRequest} IntegratedSystemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaIntegratedSystemUpdate: async (
      id: number,
      IntegratedSystemRequest: IntegratedSystemRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("metaIntegratedSystemUpdate", "id", id)
      // verify required parameter 'IntegratedSystemRequest' is not null or undefined
      assertParamExists(
        "metaIntegratedSystemUpdate",
        "IntegratedSystemRequest",
        IntegratedSystemRequest,
      )
      const localVarPath = `/api/v0/meta/integrated_system/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        IntegratedSystemRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Viewset for Product model.
     * @param {ProductRequest} ProductRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaProductCreate: async (
      ProductRequest: ProductRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ProductRequest' is not null or undefined
      assertParamExists("metaProductCreate", "ProductRequest", ProductRequest)
      const localVarPath = `/api/v0/meta/product/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        ProductRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Viewset for Product model.
     * @param {number} id A unique integer value identifying this product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaProductDestroy: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("metaProductDestroy", "id", id)
      const localVarPath = `/api/v0/meta/product/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Viewset for Product model.
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name]
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [system__slug]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaProductList: async (
      limit?: number,
      name?: string,
      offset?: number,
      system__slug?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/meta/product/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      if (system__slug !== undefined) {
        localVarQueryParameter["system__slug"] = system__slug
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Viewset for Product model.
     * @param {number} id A unique integer value identifying this product.
     * @param {PatchedProductRequest} [PatchedProductRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaProductPartialUpdate: async (
      id: number,
      PatchedProductRequest?: PatchedProductRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("metaProductPartialUpdate", "id", id)
      const localVarPath = `/api/v0/meta/product/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        PatchedProductRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Viewset for Product model.
     * @param {number} id A unique integer value identifying this product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaProductRetrieve: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("metaProductRetrieve", "id", id)
      const localVarPath = `/api/v0/meta/product/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Viewset for Product model.
     * @param {number} id A unique integer value identifying this product.
     * @param {ProductRequest} ProductRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaProductUpdate: async (
      id: number,
      ProductRequest: ProductRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("metaProductUpdate", "id", id)
      // verify required parameter 'ProductRequest' is not null or undefined
      assertParamExists("metaProductUpdate", "ProductRequest", ProductRequest)
      const localVarPath = `/api/v0/meta/product/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        ProductRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * MetaApi - functional programming interface
 * @export
 */
export const MetaApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MetaApiAxiosParamCreator(configuration)
  return {
    /**
     * Viewset for IntegratedSystem model.
     * @param {IntegratedSystemRequest} IntegratedSystemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaIntegratedSystemCreate(
      IntegratedSystemRequest: IntegratedSystemRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IntegratedSystem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.metaIntegratedSystemCreate(
          IntegratedSystemRequest,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["MetaApi.metaIntegratedSystemCreate"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {number} id A unique integer value identifying this integrated system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaIntegratedSystemDestroy(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.metaIntegratedSystemDestroy(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["MetaApi.metaIntegratedSystemDestroy"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaIntegratedSystemList(
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedIntegratedSystemList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.metaIntegratedSystemList(
          limit,
          offset,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["MetaApi.metaIntegratedSystemList"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {number} id A unique integer value identifying this integrated system.
     * @param {PatchedIntegratedSystemRequest} [PatchedIntegratedSystemRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaIntegratedSystemPartialUpdate(
      id: number,
      PatchedIntegratedSystemRequest?: PatchedIntegratedSystemRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IntegratedSystem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.metaIntegratedSystemPartialUpdate(
          id,
          PatchedIntegratedSystemRequest,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["MetaApi.metaIntegratedSystemPartialUpdate"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {number} id A unique integer value identifying this integrated system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaIntegratedSystemRetrieve(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IntegratedSystem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.metaIntegratedSystemRetrieve(
          id,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["MetaApi.metaIntegratedSystemRetrieve"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {number} id A unique integer value identifying this integrated system.
     * @param {IntegratedSystemRequest} IntegratedSystemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaIntegratedSystemUpdate(
      id: number,
      IntegratedSystemRequest: IntegratedSystemRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IntegratedSystem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.metaIntegratedSystemUpdate(
          id,
          IntegratedSystemRequest,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["MetaApi.metaIntegratedSystemUpdate"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Viewset for Product model.
     * @param {ProductRequest} ProductRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaProductCreate(
      ProductRequest: ProductRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.metaProductCreate(
          ProductRequest,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["MetaApi.metaProductCreate"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Viewset for Product model.
     * @param {number} id A unique integer value identifying this product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaProductDestroy(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.metaProductDestroy(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["MetaApi.metaProductDestroy"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Viewset for Product model.
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name]
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [system__slug]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaProductList(
      limit?: number,
      name?: string,
      offset?: number,
      system__slug?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedProductList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.metaProductList(
        limit,
        name,
        offset,
        system__slug,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["MetaApi.metaProductList"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Viewset for Product model.
     * @param {number} id A unique integer value identifying this product.
     * @param {PatchedProductRequest} [PatchedProductRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaProductPartialUpdate(
      id: number,
      PatchedProductRequest?: PatchedProductRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.metaProductPartialUpdate(
          id,
          PatchedProductRequest,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["MetaApi.metaProductPartialUpdate"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Viewset for Product model.
     * @param {number} id A unique integer value identifying this product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaProductRetrieve(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.metaProductRetrieve(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["MetaApi.metaProductRetrieve"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Viewset for Product model.
     * @param {number} id A unique integer value identifying this product.
     * @param {ProductRequest} ProductRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaProductUpdate(
      id: number,
      ProductRequest: ProductRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.metaProductUpdate(
          id,
          ProductRequest,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["MetaApi.metaProductUpdate"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * MetaApi - factory interface
 * @export
 */
export const MetaApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = MetaApiFp(configuration)
  return {
    /**
     * Viewset for IntegratedSystem model.
     * @param {MetaApiMetaIntegratedSystemCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaIntegratedSystemCreate(
      requestParameters: MetaApiMetaIntegratedSystemCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IntegratedSystem> {
      return localVarFp
        .metaIntegratedSystemCreate(
          requestParameters.IntegratedSystemRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {MetaApiMetaIntegratedSystemDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaIntegratedSystemDestroy(
      requestParameters: MetaApiMetaIntegratedSystemDestroyRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .metaIntegratedSystemDestroy(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {MetaApiMetaIntegratedSystemListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaIntegratedSystemList(
      requestParameters: MetaApiMetaIntegratedSystemListRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaginatedIntegratedSystemList> {
      return localVarFp
        .metaIntegratedSystemList(
          requestParameters.limit,
          requestParameters.offset,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {MetaApiMetaIntegratedSystemPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaIntegratedSystemPartialUpdate(
      requestParameters: MetaApiMetaIntegratedSystemPartialUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IntegratedSystem> {
      return localVarFp
        .metaIntegratedSystemPartialUpdate(
          requestParameters.id,
          requestParameters.PatchedIntegratedSystemRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {MetaApiMetaIntegratedSystemRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaIntegratedSystemRetrieve(
      requestParameters: MetaApiMetaIntegratedSystemRetrieveRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IntegratedSystem> {
      return localVarFp
        .metaIntegratedSystemRetrieve(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Viewset for IntegratedSystem model.
     * @param {MetaApiMetaIntegratedSystemUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaIntegratedSystemUpdate(
      requestParameters: MetaApiMetaIntegratedSystemUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IntegratedSystem> {
      return localVarFp
        .metaIntegratedSystemUpdate(
          requestParameters.id,
          requestParameters.IntegratedSystemRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Viewset for Product model.
     * @param {MetaApiMetaProductCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaProductCreate(
      requestParameters: MetaApiMetaProductCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Product> {
      return localVarFp
        .metaProductCreate(requestParameters.ProductRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Viewset for Product model.
     * @param {MetaApiMetaProductDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaProductDestroy(
      requestParameters: MetaApiMetaProductDestroyRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .metaProductDestroy(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Viewset for Product model.
     * @param {MetaApiMetaProductListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaProductList(
      requestParameters: MetaApiMetaProductListRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaginatedProductList> {
      return localVarFp
        .metaProductList(
          requestParameters.limit,
          requestParameters.name,
          requestParameters.offset,
          requestParameters.system__slug,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Viewset for Product model.
     * @param {MetaApiMetaProductPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaProductPartialUpdate(
      requestParameters: MetaApiMetaProductPartialUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Product> {
      return localVarFp
        .metaProductPartialUpdate(
          requestParameters.id,
          requestParameters.PatchedProductRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Viewset for Product model.
     * @param {MetaApiMetaProductRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaProductRetrieve(
      requestParameters: MetaApiMetaProductRetrieveRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Product> {
      return localVarFp
        .metaProductRetrieve(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Viewset for Product model.
     * @param {MetaApiMetaProductUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaProductUpdate(
      requestParameters: MetaApiMetaProductUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Product> {
      return localVarFp
        .metaProductUpdate(
          requestParameters.id,
          requestParameters.ProductRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for metaIntegratedSystemCreate operation in MetaApi.
 * @export
 * @interface MetaApiMetaIntegratedSystemCreateRequest
 */
export interface MetaApiMetaIntegratedSystemCreateRequest {
  /**
   *
   * @type {IntegratedSystemRequest}
   * @memberof MetaApiMetaIntegratedSystemCreate
   */
  readonly IntegratedSystemRequest: IntegratedSystemRequest
}

/**
 * Request parameters for metaIntegratedSystemDestroy operation in MetaApi.
 * @export
 * @interface MetaApiMetaIntegratedSystemDestroyRequest
 */
export interface MetaApiMetaIntegratedSystemDestroyRequest {
  /**
   * A unique integer value identifying this integrated system.
   * @type {number}
   * @memberof MetaApiMetaIntegratedSystemDestroy
   */
  readonly id: number
}

/**
 * Request parameters for metaIntegratedSystemList operation in MetaApi.
 * @export
 * @interface MetaApiMetaIntegratedSystemListRequest
 */
export interface MetaApiMetaIntegratedSystemListRequest {
  /**
   * Number of results to return per page.
   * @type {number}
   * @memberof MetaApiMetaIntegratedSystemList
   */
  readonly limit?: number

  /**
   * The initial index from which to return the results.
   * @type {number}
   * @memberof MetaApiMetaIntegratedSystemList
   */
  readonly offset?: number
}

/**
 * Request parameters for metaIntegratedSystemPartialUpdate operation in MetaApi.
 * @export
 * @interface MetaApiMetaIntegratedSystemPartialUpdateRequest
 */
export interface MetaApiMetaIntegratedSystemPartialUpdateRequest {
  /**
   * A unique integer value identifying this integrated system.
   * @type {number}
   * @memberof MetaApiMetaIntegratedSystemPartialUpdate
   */
  readonly id: number

  /**
   *
   * @type {PatchedIntegratedSystemRequest}
   * @memberof MetaApiMetaIntegratedSystemPartialUpdate
   */
  readonly PatchedIntegratedSystemRequest?: PatchedIntegratedSystemRequest
}

/**
 * Request parameters for metaIntegratedSystemRetrieve operation in MetaApi.
 * @export
 * @interface MetaApiMetaIntegratedSystemRetrieveRequest
 */
export interface MetaApiMetaIntegratedSystemRetrieveRequest {
  /**
   * A unique integer value identifying this integrated system.
   * @type {number}
   * @memberof MetaApiMetaIntegratedSystemRetrieve
   */
  readonly id: number
}

/**
 * Request parameters for metaIntegratedSystemUpdate operation in MetaApi.
 * @export
 * @interface MetaApiMetaIntegratedSystemUpdateRequest
 */
export interface MetaApiMetaIntegratedSystemUpdateRequest {
  /**
   * A unique integer value identifying this integrated system.
   * @type {number}
   * @memberof MetaApiMetaIntegratedSystemUpdate
   */
  readonly id: number

  /**
   *
   * @type {IntegratedSystemRequest}
   * @memberof MetaApiMetaIntegratedSystemUpdate
   */
  readonly IntegratedSystemRequest: IntegratedSystemRequest
}

/**
 * Request parameters for metaProductCreate operation in MetaApi.
 * @export
 * @interface MetaApiMetaProductCreateRequest
 */
export interface MetaApiMetaProductCreateRequest {
  /**
   *
   * @type {ProductRequest}
   * @memberof MetaApiMetaProductCreate
   */
  readonly ProductRequest: ProductRequest
}

/**
 * Request parameters for metaProductDestroy operation in MetaApi.
 * @export
 * @interface MetaApiMetaProductDestroyRequest
 */
export interface MetaApiMetaProductDestroyRequest {
  /**
   * A unique integer value identifying this product.
   * @type {number}
   * @memberof MetaApiMetaProductDestroy
   */
  readonly id: number
}

/**
 * Request parameters for metaProductList operation in MetaApi.
 * @export
 * @interface MetaApiMetaProductListRequest
 */
export interface MetaApiMetaProductListRequest {
  /**
   * Number of results to return per page.
   * @type {number}
   * @memberof MetaApiMetaProductList
   */
  readonly limit?: number

  /**
   *
   * @type {string}
   * @memberof MetaApiMetaProductList
   */
  readonly name?: string

  /**
   * The initial index from which to return the results.
   * @type {number}
   * @memberof MetaApiMetaProductList
   */
  readonly offset?: number

  /**
   *
   * @type {string}
   * @memberof MetaApiMetaProductList
   */
  readonly system__slug?: string
}

/**
 * Request parameters for metaProductPartialUpdate operation in MetaApi.
 * @export
 * @interface MetaApiMetaProductPartialUpdateRequest
 */
export interface MetaApiMetaProductPartialUpdateRequest {
  /**
   * A unique integer value identifying this product.
   * @type {number}
   * @memberof MetaApiMetaProductPartialUpdate
   */
  readonly id: number

  /**
   *
   * @type {PatchedProductRequest}
   * @memberof MetaApiMetaProductPartialUpdate
   */
  readonly PatchedProductRequest?: PatchedProductRequest
}

/**
 * Request parameters for metaProductRetrieve operation in MetaApi.
 * @export
 * @interface MetaApiMetaProductRetrieveRequest
 */
export interface MetaApiMetaProductRetrieveRequest {
  /**
   * A unique integer value identifying this product.
   * @type {number}
   * @memberof MetaApiMetaProductRetrieve
   */
  readonly id: number
}

/**
 * Request parameters for metaProductUpdate operation in MetaApi.
 * @export
 * @interface MetaApiMetaProductUpdateRequest
 */
export interface MetaApiMetaProductUpdateRequest {
  /**
   * A unique integer value identifying this product.
   * @type {number}
   * @memberof MetaApiMetaProductUpdate
   */
  readonly id: number

  /**
   *
   * @type {ProductRequest}
   * @memberof MetaApiMetaProductUpdate
   */
  readonly ProductRequest: ProductRequest
}

/**
 * MetaApi - object-oriented interface
 * @export
 * @class MetaApi
 * @extends {BaseAPI}
 */
export class MetaApi extends BaseAPI {
  /**
   * Viewset for IntegratedSystem model.
   * @param {MetaApiMetaIntegratedSystemCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaIntegratedSystemCreate(
    requestParameters: MetaApiMetaIntegratedSystemCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return MetaApiFp(this.configuration)
      .metaIntegratedSystemCreate(
        requestParameters.IntegratedSystemRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Viewset for IntegratedSystem model.
   * @param {MetaApiMetaIntegratedSystemDestroyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaIntegratedSystemDestroy(
    requestParameters: MetaApiMetaIntegratedSystemDestroyRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return MetaApiFp(this.configuration)
      .metaIntegratedSystemDestroy(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Viewset for IntegratedSystem model.
   * @param {MetaApiMetaIntegratedSystemListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaIntegratedSystemList(
    requestParameters: MetaApiMetaIntegratedSystemListRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return MetaApiFp(this.configuration)
      .metaIntegratedSystemList(
        requestParameters.limit,
        requestParameters.offset,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Viewset for IntegratedSystem model.
   * @param {MetaApiMetaIntegratedSystemPartialUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaIntegratedSystemPartialUpdate(
    requestParameters: MetaApiMetaIntegratedSystemPartialUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return MetaApiFp(this.configuration)
      .metaIntegratedSystemPartialUpdate(
        requestParameters.id,
        requestParameters.PatchedIntegratedSystemRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Viewset for IntegratedSystem model.
   * @param {MetaApiMetaIntegratedSystemRetrieveRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaIntegratedSystemRetrieve(
    requestParameters: MetaApiMetaIntegratedSystemRetrieveRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return MetaApiFp(this.configuration)
      .metaIntegratedSystemRetrieve(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Viewset for IntegratedSystem model.
   * @param {MetaApiMetaIntegratedSystemUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaIntegratedSystemUpdate(
    requestParameters: MetaApiMetaIntegratedSystemUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return MetaApiFp(this.configuration)
      .metaIntegratedSystemUpdate(
        requestParameters.id,
        requestParameters.IntegratedSystemRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Viewset for Product model.
   * @param {MetaApiMetaProductCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaProductCreate(
    requestParameters: MetaApiMetaProductCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return MetaApiFp(this.configuration)
      .metaProductCreate(requestParameters.ProductRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Viewset for Product model.
   * @param {MetaApiMetaProductDestroyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaProductDestroy(
    requestParameters: MetaApiMetaProductDestroyRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return MetaApiFp(this.configuration)
      .metaProductDestroy(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Viewset for Product model.
   * @param {MetaApiMetaProductListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaProductList(
    requestParameters: MetaApiMetaProductListRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return MetaApiFp(this.configuration)
      .metaProductList(
        requestParameters.limit,
        requestParameters.name,
        requestParameters.offset,
        requestParameters.system__slug,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Viewset for Product model.
   * @param {MetaApiMetaProductPartialUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaProductPartialUpdate(
    requestParameters: MetaApiMetaProductPartialUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return MetaApiFp(this.configuration)
      .metaProductPartialUpdate(
        requestParameters.id,
        requestParameters.PatchedProductRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Viewset for Product model.
   * @param {MetaApiMetaProductRetrieveRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaProductRetrieve(
    requestParameters: MetaApiMetaProductRetrieveRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return MetaApiFp(this.configuration)
      .metaProductRetrieve(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Viewset for Product model.
   * @param {MetaApiMetaProductUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaProductUpdate(
    requestParameters: MetaApiMetaProductUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return MetaApiFp(this.configuration)
      .metaProductUpdate(
        requestParameters.id,
        requestParameters.ProductRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Clear the basket for the current user.  Returns:     Response: HTTP response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsClearDestroy: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/payments/baskets/clear/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new basket item from a product for the currently logged in user. Reuse the existing basket object if it exists.  If the checkout flag is set in the POST data, then this will create the basket, then immediately flip the user to the checkout interstitial (which then redirects to the payment gateway).  Args:     system_slug (str): system slug     sku (str): product slug  POST Args:     quantity (int): quantity of the product to add to the basket (defaults to 1)     checkout (bool): redirect to checkout interstitial (defaults to False)  Returns:     Response: HTTP response
     * @param {string} sku
     * @param {string} system_slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsCreateFromProductCreate: async (
      sku: string,
      system_slug: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sku' is not null or undefined
      assertParamExists("paymentsBasketsCreateFromProductCreate", "sku", sku)
      // verify required parameter 'system_slug' is not null or undefined
      assertParamExists(
        "paymentsBasketsCreateFromProductCreate",
        "system_slug",
        system_slug,
      )
      const localVarPath =
        `/api/v0/payments/baskets/create_from_product/{system_slug}/{sku}/`
          .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
          .replace(
            `{${"system_slug"}}`,
            encodeURIComponent(String(system_slug)),
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new basket item.  Args:     request (HttpRequest): HTTP request  Returns:     Response: HTTP response
     * @param {string} basket
     * @param {BasketItemRequest} BasketItemRequest
     * @param {number} [product]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsItemsCreate: async (
      basket: string,
      BasketItemRequest: BasketItemRequest,
      product?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'basket' is not null or undefined
      assertParamExists("paymentsBasketsItemsCreate", "basket", basket)
      // verify required parameter 'BasketItemRequest' is not null or undefined
      assertParamExists(
        "paymentsBasketsItemsCreate",
        "BasketItemRequest",
        BasketItemRequest,
      )
      const localVarPath = `/api/v0/payments/baskets/{basket}/items/`.replace(
        `{${"basket"}}`,
        encodeURIComponent(String(basket)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (product !== undefined) {
        localVarQueryParameter["product"] = product
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        BasketItemRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * API view set for BasketItem
     * @param {string} basket
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsItemsDestroy: async (
      basket: string,
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'basket' is not null or undefined
      assertParamExists("paymentsBasketsItemsDestroy", "basket", basket)
      // verify required parameter 'id' is not null or undefined
      assertParamExists("paymentsBasketsItemsDestroy", "id", id)
      const localVarPath = `/api/v0/payments/baskets/{basket}/items/{id}/`
        .replace(`{${"basket"}}`, encodeURIComponent(String(basket)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * API view set for BasketItem
     * @param {string} basket
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsItemsList: async (
      basket: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'basket' is not null or undefined
      assertParamExists("paymentsBasketsItemsList", "basket", basket)
      const localVarPath = `/api/v0/payments/baskets/{basket}/items/`.replace(
        `{${"basket"}}`,
        encodeURIComponent(String(basket)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * API view set for Basket
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsList: async (
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/payments/baskets/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * API view set for Basket
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsRetrieve: async (
      username: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("paymentsBasketsRetrieve", "username", username)
      const localVarPath = `/api/v0/payments/baskets/{username}/`.replace(
        `{${"username"}}`,
        encodeURIComponent(String(username)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Handle webhook call from the payment gateway when the user has completed a transaction.  Returns:     - HTTP_200_OK if the Order is found.  Raises:     - Http404 if the Order is not found.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsCheckoutCallbackCreate: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/payments/checkout/callback/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start the checkout process. This assembles the basket items into an Order with Lines for each item, applies the attached basket discounts, and then calls the payment gateway to prepare for payment.  This is expected to be called from within the Ecommerce cart app, not from an integrated system.  Returns:     - JSON payload from the ol-django payment gateway app. The payment       gateway returns data necessary to construct a form that will       ultimately POST to the actual payment processor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsCheckoutStartCheckoutCreate: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/payments/checkout/start_checkout/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Provides APIs for displaying the users\'s order history.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsOrdersHistoryList: async (
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v0/payments/orders/history/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Provides APIs for displaying the users\'s order history.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsOrdersHistoryRetrieve: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("paymentsOrdersHistoryRetrieve", "id", id)
      const localVarPath = `/api/v0/payments/orders/history/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
  return {
    /**
     * Clear the basket for the current user.  Returns:     Response: HTTP response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentsBasketsClearDestroy(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentsBasketsClearDestroy(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PaymentsApi.paymentsBasketsClearDestroy"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Create a new basket item from a product for the currently logged in user. Reuse the existing basket object if it exists.  If the checkout flag is set in the POST data, then this will create the basket, then immediately flip the user to the checkout interstitial (which then redirects to the payment gateway).  Args:     system_slug (str): system slug     sku (str): product slug  POST Args:     quantity (int): quantity of the product to add to the basket (defaults to 1)     checkout (bool): redirect to checkout interstitial (defaults to False)  Returns:     Response: HTTP response
     * @param {string} sku
     * @param {string} system_slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentsBasketsCreateFromProductCreate(
      sku: string,
      system_slug: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentsBasketsCreateFromProductCreate(
          sku,
          system_slug,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "PaymentsApi.paymentsBasketsCreateFromProductCreate"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Create a new basket item.  Args:     request (HttpRequest): HTTP request  Returns:     Response: HTTP response
     * @param {string} basket
     * @param {BasketItemRequest} BasketItemRequest
     * @param {number} [product]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentsBasketsItemsCreate(
      basket: string,
      BasketItemRequest: BasketItemRequest,
      product?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketItem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentsBasketsItemsCreate(
          basket,
          BasketItemRequest,
          product,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PaymentsApi.paymentsBasketsItemsCreate"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * API view set for BasketItem
     * @param {string} basket
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentsBasketsItemsDestroy(
      basket: string,
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentsBasketsItemsDestroy(
          basket,
          id,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PaymentsApi.paymentsBasketsItemsDestroy"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * API view set for BasketItem
     * @param {string} basket
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentsBasketsItemsList(
      basket: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedBasketItemList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentsBasketsItemsList(
          basket,
          limit,
          offset,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PaymentsApi.paymentsBasketsItemsList"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * API view set for Basket
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentsBasketsList(
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedBasketList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentsBasketsList(
          limit,
          offset,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PaymentsApi.paymentsBasketsList"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * API view set for Basket
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentsBasketsRetrieve(
      username: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Basket>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentsBasketsRetrieve(
          username,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PaymentsApi.paymentsBasketsRetrieve"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Handle webhook call from the payment gateway when the user has completed a transaction.  Returns:     - HTTP_200_OK if the Order is found.  Raises:     - Http404 if the Order is not found.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentsCheckoutCallbackCreate(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentsCheckoutCallbackCreate(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PaymentsApi.paymentsCheckoutCallbackCreate"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Start the checkout process. This assembles the basket items into an Order with Lines for each item, applies the attached basket discounts, and then calls the payment gateway to prepare for payment.  This is expected to be called from within the Ecommerce cart app, not from an integrated system.  Returns:     - JSON payload from the ol-django payment gateway app. The payment       gateway returns data necessary to construct a form that will       ultimately POST to the actual payment processor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentsCheckoutStartCheckoutCreate(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentsCheckoutStartCheckoutCreate(
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PaymentsApi.paymentsCheckoutStartCheckoutCreate"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Provides APIs for displaying the users\'s order history.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentsOrdersHistoryList(
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedOrderHistoryList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentsOrdersHistoryList(
          limit,
          offset,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PaymentsApi.paymentsOrdersHistoryList"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Provides APIs for displaying the users\'s order history.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentsOrdersHistoryRetrieve(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderHistory>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentsOrdersHistoryRetrieve(
          id,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PaymentsApi.paymentsOrdersHistoryRetrieve"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PaymentsApiFp(configuration)
  return {
    /**
     * Clear the basket for the current user.  Returns:     Response: HTTP response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsClearDestroy(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .paymentsBasketsClearDestroy(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new basket item from a product for the currently logged in user. Reuse the existing basket object if it exists.  If the checkout flag is set in the POST data, then this will create the basket, then immediately flip the user to the checkout interstitial (which then redirects to the payment gateway).  Args:     system_slug (str): system slug     sku (str): product slug  POST Args:     quantity (int): quantity of the product to add to the basket (defaults to 1)     checkout (bool): redirect to checkout interstitial (defaults to False)  Returns:     Response: HTTP response
     * @param {PaymentsApiPaymentsBasketsCreateFromProductCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsCreateFromProductCreate(
      requestParameters: PaymentsApiPaymentsBasketsCreateFromProductCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .paymentsBasketsCreateFromProductCreate(
          requestParameters.sku,
          requestParameters.system_slug,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new basket item.  Args:     request (HttpRequest): HTTP request  Returns:     Response: HTTP response
     * @param {PaymentsApiPaymentsBasketsItemsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsItemsCreate(
      requestParameters: PaymentsApiPaymentsBasketsItemsCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BasketItem> {
      return localVarFp
        .paymentsBasketsItemsCreate(
          requestParameters.basket,
          requestParameters.BasketItemRequest,
          requestParameters.product,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * API view set for BasketItem
     * @param {PaymentsApiPaymentsBasketsItemsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsItemsDestroy(
      requestParameters: PaymentsApiPaymentsBasketsItemsDestroyRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .paymentsBasketsItemsDestroy(
          requestParameters.basket,
          requestParameters.id,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * API view set for BasketItem
     * @param {PaymentsApiPaymentsBasketsItemsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsItemsList(
      requestParameters: PaymentsApiPaymentsBasketsItemsListRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaginatedBasketItemList> {
      return localVarFp
        .paymentsBasketsItemsList(
          requestParameters.basket,
          requestParameters.limit,
          requestParameters.offset,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * API view set for Basket
     * @param {PaymentsApiPaymentsBasketsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsList(
      requestParameters: PaymentsApiPaymentsBasketsListRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaginatedBasketList> {
      return localVarFp
        .paymentsBasketsList(
          requestParameters.limit,
          requestParameters.offset,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * API view set for Basket
     * @param {PaymentsApiPaymentsBasketsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsBasketsRetrieve(
      requestParameters: PaymentsApiPaymentsBasketsRetrieveRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Basket> {
      return localVarFp
        .paymentsBasketsRetrieve(requestParameters.username, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Handle webhook call from the payment gateway when the user has completed a transaction.  Returns:     - HTTP_200_OK if the Order is found.  Raises:     - Http404 if the Order is not found.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsCheckoutCallbackCreate(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .paymentsCheckoutCallbackCreate(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Start the checkout process. This assembles the basket items into an Order with Lines for each item, applies the attached basket discounts, and then calls the payment gateway to prepare for payment.  This is expected to be called from within the Ecommerce cart app, not from an integrated system.  Returns:     - JSON payload from the ol-django payment gateway app. The payment       gateway returns data necessary to construct a form that will       ultimately POST to the actual payment processor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsCheckoutStartCheckoutCreate(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .paymentsCheckoutStartCheckoutCreate(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Provides APIs for displaying the users\'s order history.
     * @param {PaymentsApiPaymentsOrdersHistoryListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsOrdersHistoryList(
      requestParameters: PaymentsApiPaymentsOrdersHistoryListRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaginatedOrderHistoryList> {
      return localVarFp
        .paymentsOrdersHistoryList(
          requestParameters.limit,
          requestParameters.offset,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Provides APIs for displaying the users\'s order history.
     * @param {PaymentsApiPaymentsOrdersHistoryRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentsOrdersHistoryRetrieve(
      requestParameters: PaymentsApiPaymentsOrdersHistoryRetrieveRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<OrderHistory> {
      return localVarFp
        .paymentsOrdersHistoryRetrieve(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for paymentsBasketsCreateFromProductCreate operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsBasketsCreateFromProductCreateRequest
 */
export interface PaymentsApiPaymentsBasketsCreateFromProductCreateRequest {
  /**
   *
   * @type {string}
   * @memberof PaymentsApiPaymentsBasketsCreateFromProductCreate
   */
  readonly sku: string

  /**
   *
   * @type {string}
   * @memberof PaymentsApiPaymentsBasketsCreateFromProductCreate
   */
  readonly system_slug: string
}

/**
 * Request parameters for paymentsBasketsItemsCreate operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsBasketsItemsCreateRequest
 */
export interface PaymentsApiPaymentsBasketsItemsCreateRequest {
  /**
   *
   * @type {string}
   * @memberof PaymentsApiPaymentsBasketsItemsCreate
   */
  readonly basket: string

  /**
   *
   * @type {BasketItemRequest}
   * @memberof PaymentsApiPaymentsBasketsItemsCreate
   */
  readonly BasketItemRequest: BasketItemRequest

  /**
   *
   * @type {number}
   * @memberof PaymentsApiPaymentsBasketsItemsCreate
   */
  readonly product?: number
}

/**
 * Request parameters for paymentsBasketsItemsDestroy operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsBasketsItemsDestroyRequest
 */
export interface PaymentsApiPaymentsBasketsItemsDestroyRequest {
  /**
   *
   * @type {string}
   * @memberof PaymentsApiPaymentsBasketsItemsDestroy
   */
  readonly basket: string

  /**
   *
   * @type {string}
   * @memberof PaymentsApiPaymentsBasketsItemsDestroy
   */
  readonly id: string
}

/**
 * Request parameters for paymentsBasketsItemsList operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsBasketsItemsListRequest
 */
export interface PaymentsApiPaymentsBasketsItemsListRequest {
  /**
   *
   * @type {string}
   * @memberof PaymentsApiPaymentsBasketsItemsList
   */
  readonly basket: string

  /**
   * Number of results to return per page.
   * @type {number}
   * @memberof PaymentsApiPaymentsBasketsItemsList
   */
  readonly limit?: number

  /**
   * The initial index from which to return the results.
   * @type {number}
   * @memberof PaymentsApiPaymentsBasketsItemsList
   */
  readonly offset?: number
}

/**
 * Request parameters for paymentsBasketsList operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsBasketsListRequest
 */
export interface PaymentsApiPaymentsBasketsListRequest {
  /**
   * Number of results to return per page.
   * @type {number}
   * @memberof PaymentsApiPaymentsBasketsList
   */
  readonly limit?: number

  /**
   * The initial index from which to return the results.
   * @type {number}
   * @memberof PaymentsApiPaymentsBasketsList
   */
  readonly offset?: number
}

/**
 * Request parameters for paymentsBasketsRetrieve operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsBasketsRetrieveRequest
 */
export interface PaymentsApiPaymentsBasketsRetrieveRequest {
  /**
   *
   * @type {string}
   * @memberof PaymentsApiPaymentsBasketsRetrieve
   */
  readonly username: string
}

/**
 * Request parameters for paymentsOrdersHistoryList operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsOrdersHistoryListRequest
 */
export interface PaymentsApiPaymentsOrdersHistoryListRequest {
  /**
   * Number of results to return per page.
   * @type {number}
   * @memberof PaymentsApiPaymentsOrdersHistoryList
   */
  readonly limit?: number

  /**
   * The initial index from which to return the results.
   * @type {number}
   * @memberof PaymentsApiPaymentsOrdersHistoryList
   */
  readonly offset?: number
}

/**
 * Request parameters for paymentsOrdersHistoryRetrieve operation in PaymentsApi.
 * @export
 * @interface PaymentsApiPaymentsOrdersHistoryRetrieveRequest
 */
export interface PaymentsApiPaymentsOrdersHistoryRetrieveRequest {
  /**
   *
   * @type {string}
   * @memberof PaymentsApiPaymentsOrdersHistoryRetrieve
   */
  readonly id: string
}

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
  /**
   * Clear the basket for the current user.  Returns:     Response: HTTP response
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public paymentsBasketsClearDestroy(options?: RawAxiosRequestConfig) {
    return PaymentsApiFp(this.configuration)
      .paymentsBasketsClearDestroy(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new basket item from a product for the currently logged in user. Reuse the existing basket object if it exists.  If the checkout flag is set in the POST data, then this will create the basket, then immediately flip the user to the checkout interstitial (which then redirects to the payment gateway).  Args:     system_slug (str): system slug     sku (str): product slug  POST Args:     quantity (int): quantity of the product to add to the basket (defaults to 1)     checkout (bool): redirect to checkout interstitial (defaults to False)  Returns:     Response: HTTP response
   * @param {PaymentsApiPaymentsBasketsCreateFromProductCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public paymentsBasketsCreateFromProductCreate(
    requestParameters: PaymentsApiPaymentsBasketsCreateFromProductCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PaymentsApiFp(this.configuration)
      .paymentsBasketsCreateFromProductCreate(
        requestParameters.sku,
        requestParameters.system_slug,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new basket item.  Args:     request (HttpRequest): HTTP request  Returns:     Response: HTTP response
   * @param {PaymentsApiPaymentsBasketsItemsCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public paymentsBasketsItemsCreate(
    requestParameters: PaymentsApiPaymentsBasketsItemsCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PaymentsApiFp(this.configuration)
      .paymentsBasketsItemsCreate(
        requestParameters.basket,
        requestParameters.BasketItemRequest,
        requestParameters.product,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * API view set for BasketItem
   * @param {PaymentsApiPaymentsBasketsItemsDestroyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public paymentsBasketsItemsDestroy(
    requestParameters: PaymentsApiPaymentsBasketsItemsDestroyRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PaymentsApiFp(this.configuration)
      .paymentsBasketsItemsDestroy(
        requestParameters.basket,
        requestParameters.id,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * API view set for BasketItem
   * @param {PaymentsApiPaymentsBasketsItemsListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public paymentsBasketsItemsList(
    requestParameters: PaymentsApiPaymentsBasketsItemsListRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PaymentsApiFp(this.configuration)
      .paymentsBasketsItemsList(
        requestParameters.basket,
        requestParameters.limit,
        requestParameters.offset,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * API view set for Basket
   * @param {PaymentsApiPaymentsBasketsListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public paymentsBasketsList(
    requestParameters: PaymentsApiPaymentsBasketsListRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return PaymentsApiFp(this.configuration)
      .paymentsBasketsList(
        requestParameters.limit,
        requestParameters.offset,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * API view set for Basket
   * @param {PaymentsApiPaymentsBasketsRetrieveRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public paymentsBasketsRetrieve(
    requestParameters: PaymentsApiPaymentsBasketsRetrieveRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PaymentsApiFp(this.configuration)
      .paymentsBasketsRetrieve(requestParameters.username, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Handle webhook call from the payment gateway when the user has completed a transaction.  Returns:     - HTTP_200_OK if the Order is found.  Raises:     - Http404 if the Order is not found.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public paymentsCheckoutCallbackCreate(options?: RawAxiosRequestConfig) {
    return PaymentsApiFp(this.configuration)
      .paymentsCheckoutCallbackCreate(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Start the checkout process. This assembles the basket items into an Order with Lines for each item, applies the attached basket discounts, and then calls the payment gateway to prepare for payment.  This is expected to be called from within the Ecommerce cart app, not from an integrated system.  Returns:     - JSON payload from the ol-django payment gateway app. The payment       gateway returns data necessary to construct a form that will       ultimately POST to the actual payment processor.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public paymentsCheckoutStartCheckoutCreate(options?: RawAxiosRequestConfig) {
    return PaymentsApiFp(this.configuration)
      .paymentsCheckoutStartCheckoutCreate(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Provides APIs for displaying the users\'s order history.
   * @param {PaymentsApiPaymentsOrdersHistoryListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public paymentsOrdersHistoryList(
    requestParameters: PaymentsApiPaymentsOrdersHistoryListRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return PaymentsApiFp(this.configuration)
      .paymentsOrdersHistoryList(
        requestParameters.limit,
        requestParameters.offset,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Provides APIs for displaying the users\'s order history.
   * @param {PaymentsApiPaymentsOrdersHistoryRetrieveRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public paymentsOrdersHistoryRetrieve(
    requestParameters: PaymentsApiPaymentsOrdersHistoryRetrieveRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PaymentsApiFp(this.configuration)
      .paymentsOrdersHistoryRetrieve(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
